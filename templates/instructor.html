<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Privilege Walk - Instructor View</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
            min-height: 100vh;
        }
        
        .header {
            text-align: center;
            margin-bottom: 2rem;
        }
        
        .session-name {
            font-size: 2rem;
            color: #333;
            margin-bottom: 0.5rem;
        }
        
        .session-id {
            color: #666;
            font-size: 1.1rem;
        }
        
        .main-content {
            display: flex;
            gap: 3rem;
            max-width: 1200px;
            margin: 0 auto;
            align-items: flex-start;
        }
        
        .left-panel {
            flex: 1;
            background: white;
            padding: 2rem;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            text-align: center;
        }
        
        .right-panel {
            flex: 1;
            background: white;
            padding: 2rem;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .network-info {
            background: #f8f9fa;
            padding: 1.5rem;
            border-radius: 10px;
            margin-bottom: 2rem;
            border-left: 4px solid #667eea;
        }
        
        .network-info h3 {
            margin: 0 0 1rem 0;
            color: #333;
            font-size: 1.2rem;
        }
        
        .ip-address {
            background: #667eea;
            color: white;
            padding: 0.75rem;
            border-radius: 8px;
            font-family: monospace;
            font-size: 1.2rem;
            font-weight: 600;
            text-align: center;
            margin: 0.5rem 0;
        }
        
        .ip-note {
            color: #666;
            font-size: 0.9rem;
            margin: 0.5rem 0 0 0;
            text-align: center;
        }
        
        .qr-container {
            margin: 2rem 0;
            padding: 2rem;
            border: 2px dashed #ddd;
            border-radius: 10px;
        }
        
        .qr-instructions {
            margin-bottom: 2rem;
            text-align: left;
        }
        
        .qr-instructions ol {
            text-align: left;
            margin: 0;
            padding-left: 1.5rem;
        }
        
        .qr-instructions li {
            margin: 0.5rem 0;
            color: #555;
        }
        
        .qr-code {
            margin: 2rem 0;
            padding: 2rem;
            border: 2px dashed #ddd;
            border-radius: 10px;
            text-align: center;
        }
        
        .qr-code img {
            max-width: 300px;
            height: auto;
            margin-bottom: 1rem;
        }
        
        .qr-controls {
            margin-top: 1rem;
        }
        
        .refresh-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
        }
        
        .refresh-btn:hover {
            background: #0056b3;
        }
        
        .url-display {
            background: #f8f9fa;
            padding: 0.75rem;
            border-radius: 5px;
            font-family: monospace;
            font-size: 0.9rem;
            margin: 0.5rem 0;
            word-break: break-all;
        }
        
        .debug-info {
            font-size: 0.8rem;
            color: #888;
            margin-top: 1rem;
        }
        
        .status {
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-weight: 600;
        }
        
        .status.waiting {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        
        .status.active {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status.finished {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        .testing-note {
            background: #e7f3ff;
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
            border-left: 4px solid #007bff;
        }
        
        .user-count {
            font-size: 3rem;
            font-weight: bold;
            color: #667eea;
            margin: 1rem 0;
        }
        
        .go-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 1rem 2rem;
            border-radius: 10px;
            font-size: 1.2rem;
            font-weight: 600;
            cursor: pointer;
            margin: 1rem 0;
            transition: all 0.3s ease;
        }
        
        .go-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }
        
        .go-button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .user-list {
            margin-top: 1rem;
        }
        
        .user-item {
            background: #f8f9fa;
            padding: 1rem;
            margin: 0.5rem 0;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }
        
        .user-count-display {
            background: #e7f3ff;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            border-left: 4px solid #007bff;
            text-align: center;
        }
        
        .total-users {
            font-size: 1.2rem;
            font-weight: 600;
            color: #0056b3;
        }
        
        .question-progress-display {
            background: #fff3cd;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            border-left: 4px solid #ffc107;
        }
        
        .question-progress-display.all-answered {
            background: #d4edda;
            border-left-color: #28a745;
        }
        
        .question-progress-display h3 {
            margin: 0 0 0.5rem 0;
            color: #856404;
            font-size: 1rem;
        }
        
        .question-progress-display.all-answered h3 {
            color: #155724;
        }
        
        .current-question {
            font-weight: 600;
            color: #856404;
            margin-bottom: 0.5rem;
        }
        
        .question-progress-display.all-answered .current-question {
            color: #155724;
        }
        
        .answered-status {
            font-size: 0.9rem;
            color: #856404;
        }
        
        .question-progress-display.all-answered .answered-status {
            color: #155724;
        }
        
        .next-question-btn {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            margin-top: 1rem;
            width: 100%;
            transition: all 0.3s ease;
        }
        
        .next-question-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.3);
        }
        
        .user-item.answered {
            border-left-color: #28a745;
            background: #d4edda;
        }
        
        .user-item.pending {
            border-left-color: #ffc107;
            background: #fff3cd;
        }
        
        .privilege-walk-view {
            display: none;
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 2rem;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .walk-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid #eee;
        }
        
        .back-btn {
            background: #6c757d;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
        }
        
        .question-display {
            text-align: center;
            margin-bottom: 2rem;
            padding: 2rem;
            background: #f8f9fa;
            border-radius: 10px;
        }
        
        .question-text {
            font-size: 1.5rem;
            color: #333;
            margin-bottom: 1rem;
            font-weight: 600;
        }
        
        .question-progress {
            color: #666;
            font-size: 1.1rem;
        }
        
        .walk-container {
            position: relative;
            height: 600px;
            background: linear-gradient(to bottom, #e8f5e8 0%, #f0f8f0 50%, #f8e8e8 100%);
            border-radius: 10px;
            border: 2px solid #ddd;
            margin: 2rem 0;
            overflow: hidden;
        }
        
        .walk-grid {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: grid;
            /* Grid rows and columns will be set dynamically via JavaScript */
            gap: 1px;
            pointer-events: none;
            z-index: 1;
        }
        
        .grid-cell {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .grid-label-cell {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: 600;
            color: #666;
            text-align: center;
        }
        

        
        .user-marker {
            position: absolute;
            background: #667eea;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-weight: 600;
            text-align: center;
            min-width: 120px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            transition: all 0.5s ease;
            font-size: 0.9rem;
            z-index: 3;
            transform: translate(-50%, -50%); /* Center the marker on the grid position */
        }
        
        .user-marker.answered {
            background: #28a745;
        }
        
        .user-marker.pending {
            background: #ffc107;
            color: #333;
        }
        
        .final-results {
            display: none;
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 2rem;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            text-align: center;
        }
        
        .final-positions {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin: 2rem 0;
        }
        
        .position-card {
            background: #f8f9fa;
            padding: 1.5rem;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }
        
        .position-rank {
            font-size: 2rem;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 0.5rem;
        }
        
        .position-name {
            font-size: 1.2rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 0.5rem;
        }
        
        .position-value {
            color: #666;
        }
        
        .session-actions {
            margin-top: 2rem;
            padding-top: 2rem;
            border-top: 2px solid #eee;
        }
        
        .action-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 1rem;
        }
        
        .action-btn {
            padding: 1rem 2rem;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .reset-btn {
            background: linear-gradient(135deg, #ffc107 0%, #fd7e14 100%);
            color: white;
        }
        
        .new-btn {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
        }
        .header-actions {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
        }
        
        .resume-btn {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .resume-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.3);
        }
        .copy-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 0.5rem;
            font-size: 0.9rem;
        }
        
        .copy-btn:hover {
            background: #218838;
        }
        
        .session-controls {
            margin: 2rem 0;
        }
        
        .start-btn, .stop-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 1rem 2rem;
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            margin: 0.5rem;
            transition: transform 0.2s ease;
        }
        
        .start-btn:hover, .stop-btn:hover {
            transform: translateY(-2px);
        }
        
        .stop-btn {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
        }
        
        .question-display {
            margin-top: 2rem;
            padding: 1.5rem;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }
        
        .question-display h3 {
            margin: 0 0 1rem 0;
            color: #333;
        }
        
        .question-text {
            color: #666;
            line-height: 1.6;
            font-style: italic;
        }
        
        .participant-display {
            margin-top: 2rem;
            padding: 1.5rem;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }
        
        .participant-display h3 {
            margin: 0 0 1rem 0;
            color: #333;
            font-size: 1.1rem;
        }
        
        .participant-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .participant-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background: white;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }
        
        .participant-name {
            font-weight: 600;
            color: #333;
        }
        
        .participant-score {
            font-weight: 600;
            color: #667eea;
            font-size: 1.1rem;
        }
        
        .participant-answered {
            border-left-color: #28a745;
        }
        
        .participant-pending {
            border-left-color: #ffc107;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1 class="session-name">üö∂‚Äç‚ôÇÔ∏è Privilege Walk Session</h1>
        <p class="session-id">Session ID: {{ session_id }}</p>
        <p class="session-subtitle">Welcome! Scan the QR code below to join this session</p>
    </div>
    

    
    <div class="main-content">
        <div class="left-panel">
            <h2>üì± Join This Session</h2>
            
            <div class="qr-container">
                <div class="qr-instructions">
                    <h3>How to Join:</h3>
                    <ol>
                        <li>üì± Scan this QR code with your phone camera</li>
                        <li>üåê You'll be taken to a join page</li>
                        <li>‚úèÔ∏è Enter a nickname (can be fake)</li>
                        <li>‚è≥ You'll see "Please wait" until the session starts</li>
                    </ol>
                </div>
                
                <div class="qr-code" id="qrCode">
                    <img id="qrCodeImage" src="/qr/{{ session_id }}" alt="QR Code for joining session" style="max-width: 300px; height: auto;">
                    <div class="qr-controls">
                        <button onclick="refreshQRCode()" class="refresh-btn">üîÑ Refresh QR Code</button>
                    </div>
                </div>
                
                <div class="join-url">
                    <p><strong>Join URL:</strong></p>
                    <div class="url-display" id="joinUrl">Loading...</div>
                    <button class="copy-btn" onclick="copyJoinURL()">üìã Copy URL</button>
                </div>
            </div>
            
            <div class="session-controls">
                <button class="start-btn" id="startBtn">üöÄ Begin Privilege Walk</button>
                <button class="stop-btn" id="stopBtn" onclick="stopSession()" style="display: none;">‚èπÔ∏è End Session</button>
            </div>
            
            <div class="question-display">
                <h3>Current Question:</h3>
                <div class="question-text" id="questionDisplay">Session not started yet</div>
            </div>
        </div>
        
        <div class="right-panel">
            <h2>üë• Who's Joined</h2>
            <div class="user-count-display">
                <div class="total-users">Total Participants: <span id="totalUserCount">0</span></div>
                <div id="sessionStatusMessage" style="margin-top: 0.5rem; padding: 0.5rem; background: #d4edda; color: #155724; border-radius: 5px; font-size: 0.9rem;">
                    ‚úÖ Session is ready - participants can join now!
                </div>
                <button onclick="manualRefresh()" style="margin-top: 0.5rem; padding: 0.5rem 1rem; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">üîÑ Refresh List</button>
            </div>
            <div class="question-progress-display" id="questionProgressDisplay" style="display: none;">
                <h3>üìù Question Progress</h3>
                <div class="current-question" id="currentQuestionDisplay"></div>
                <div class="answered-status" id="answeredStatusDisplay"></div>
                <button class="next-question-btn" id="nextQuestionBtn" style="display: none;" onclick="advanceToNextQuestion()">
                    ‚û°Ô∏è Next Question
                </button>
            </div>
            <div class="user-list" id="userList">
                <p style="text-align: center; color: #666;">No participants have joined yet</p>
            </div>
            
            <!-- Participant display during questions -->
            <div class="participant-display" id="participantDisplay" style="display: none;">
                <h3>üë• Current Participants & Scores</h3>
                <div class="participant-list" id="participantList">
                    <!-- Participants will be displayed here during questions -->
                </div>
            </div>
        </div>
    </div>
    
    <div class="privilege-walk-view" id="privilegeWalkView">
        <div class="walk-header">
            <h2>üö∂‚Äç‚ôÇÔ∏è Privilege Walk in Progress</h2>
            <button onclick="showMainView()" class="back-btn">‚Üê Back to Setup</button>
        </div>
        
        <div class="question-display" id="questionDisplay">
            <div class="question-text" id="questionText"></div>
            <div class="question-progress" id="questionProgress"></div>
        </div>
        
        <div class="walk-container" id="walkContainer">
            <div class="walk-grid" id="walkGrid">
                <!-- Grid will be generated dynamically -->
            </div>
            <!-- User markers will be dynamically added here -->
        </div>
    </div>
    
    <div class="final-results" id="finalResults">
        <h2>üèÅ Final Results</h2>
        <div class="final-positions" id="finalPositions">
            <!-- Final positions will be displayed here -->
        </div>
        
        <div class="session-actions">
            <h3>üîÑ What would you like to do next?</h3>
            <div class="action-buttons">
                <button onclick="resetSession()" class="action-btn reset-btn">
                    üîÑ Reset Session (Same Students, New Questions)
                </button>
                <button onclick="createNewSession()" class="action-btn new-btn">
                    üÜï Create New Session (Fresh Start)
                </button>
                <button onclick="showMainView()" class="action-btn back-btn">
                    ‚Üê Back to Setup
                </button>
            </div>
        </div>
    </div>

    <script>
        const sessionId = '{{ session_id }}';
        const networkIp = '{{ network_ip }}';
        
        let currentQuestion = 0;
        let totalQuestions = 0;
        let questionText = '';
        let users = {};
        let userAnswers = {};
        let userCount = 0;
        let pollInterval = null;
        let positionsLoaded = false; // Flag to track if positions have been loaded
        let lastKnownPositions = {}; // Store last known positions to detect changes
        let lastKnownQuestion = 0; // Store last known question to detect changes
        let gridCreated = false; // Flag to track if grid has been created

        function startPolling() {
            // Poll every 2 seconds for updates
            pollInterval = setInterval(async () => {
                try {
                    const response = await fetch(`/api/session_status/${sessionId}`);
                    if (response.ok) {
                        const data = await response.json();
                        await handleStatusUpdate(data);
                        
                        // If session is active, DO NOT update positions during regular polling
                        // This prevents the flashing effect - positions only update on real score changes
                        if (data.status === 'active') {
                            // Positions are updated separately when there are actual score changes
                            // Not during regular status polling to prevent flashing
                            console.log('Session active - positions stable during polling');
                        }
                    }
                } catch (error) {
                    console.error('Polling error:', error);
                }
            }, 2000);
        }

        async function handleStatusUpdate(data) {
            console.log('Status update received:', data);
            console.log('Previous user count:', userCount, 'Previous users:', users);
            
            // Update user count and list FIRST (regardless of status)
            const newUserCount = data.user_count || 0;
            const newUsers = data.users || [];
            
            console.log('New user count:', newUserCount, 'New users:', newUsers);
            
            // Only update if there are actual changes
            if (newUserCount !== userCount || JSON.stringify(newUsers) !== JSON.stringify(users)) {
                userCount = newUserCount;
                users = newUsers;
                
                console.log('User data changed, updating display...');
                
                // Update user count display
                const userCountDisplay = document.getElementById('totalUserCount');
                if (userCountDisplay) {
                    userCountDisplay.textContent = userCount;
                }
                
                // Update user list
                updateUserList();
                
                // Update participant display
                updateParticipantDisplay();
            }
            
            // Then handle session status changes
            if (data.status === 'waiting') {
                showMainView();
                // Even in waiting status, we want to show users who have joined
                console.log('Session is waiting, but users can still join');
            } else if (data.status === 'active') {
                await showPrivilegeWalkView();
                updateQuestionProgress();
                loadUserPositions();
                loadUserAnswers();
            } else if (data.status === 'finished') {
                showFinalView();
            }
            
            // Update the session status message
            updateSessionStatusMessage(data.status);
            
            // Update participant display after status change
            updateParticipantDisplay();
        }

        async function loadCurrentQuestion() {
            try {
                const response = await fetch(`/api/session_status/${sessionId}`);
                if (response.ok) {
                    const data = await response.json();
                    currentQuestion = data.current_question;
                    totalQuestions = data.total_questions;
                    
                    // Set global variable for grid sizing
                    window.totalQuestions = totalQuestions;
                    
                    // Always try to get the current question text, regardless of status
                    if (currentQuestion < totalQuestions) {
                        const questionResponse = await fetch(`/api/question/${sessionId}`);
                        if (questionResponse.ok) {
                            const questionData = await questionResponse.json();
                            questionText = questionData.question;
                            
                            // Update question display using the proper function
                            updateQuestionDisplay(questionText, currentQuestion + 1, totalQuestions);
                        }
                    } else {
                        // No more questions, clear the display
                        updateQuestionDisplay('Session completed - no more questions', totalQuestions, totalQuestions);
                    }
                    
                    // Update question progress
                    updateQuestionProgress();
                    
                    // Update participant display when question changes
                    updateParticipantDisplay();
                }
            } catch (error) {
                console.error('Error loading current question:', error);
            }
        }

        async function loadUserPositions() {
            try {
                const response = await fetch(`/api/positions/${sessionId}`);
                if (response.ok) {
                    const data = await response.json();
                    updateUserPositions(data.positions);
                    
                    // Update participant scores in the display
                    if (data.positions) {
                        Object.keys(data.positions).forEach(username => {
                            const scoreElement = document.getElementById(`score-${username}`);
                            if (scoreElement) {
                                scoreElement.textContent = data.positions[username];
                            }
                        });
                    }
                    
                    // Store current positions for change detection
                    lastKnownPositions = { ...data.positions };
                    
                    // Mark positions as loaded
                    positionsLoaded = true;
                }
            } catch (error) {
                console.error('Error loading positions:', error);
            }
        }

        async function loadUserAnswers() {
            try {
                // Get current user answer status from the dedicated endpoint
                const response = await fetch(`/api/user_answers/${sessionId}`);
                if (response.ok) {
                    const data = await response.json();
                    
                    // Update user answers based on the API response
                    userAnswers = {};
                    if (data.user_answers) {
                        Object.keys(data.user_answers).forEach(username => {
                            userAnswers[username] = data.user_answers[username].answered;
                        });
                    }
                    
                    updateUserAnswerStatus(data);
                }
            } catch (error) {
                console.error('Error loading user answers:', error);
            }
        }

        async function loadUserCount() {
            try {
                console.log('loadUserCount called, fetching session status...');
                const response = await fetch(`/api/session_status/${sessionId}`);
                if (response.ok) {
                    const data = await response.json();
                    console.log('loadUserCount received data:', data);
                    
                    userCount = data.user_count;
                    users = data.users;
                    
                    console.log('Updated userCount to:', userCount, 'and users to:', users);
                    
                    // Update user count display
                    const userCountDisplay = document.getElementById('totalUserCount');
                    if (userCountDisplay) {
                        userCountDisplay.textContent = userCount;
                        console.log('Updated user count display to:', userCount);
                    } else {
                        console.error('totalUserCount element not found!');
                    }
                    
                    // Update user list
                    updateUserList();
                } else {
                    console.error('loadUserCount failed with status:', response.status);
                }
            } catch (error) {
                console.error('Error loading user count:', error);
            }
        }
        
        function updateUserList() {
            console.log('updateUserList called with userCount:', userCount, 'users:', users);
            
            const userList = document.getElementById('userList');
            if (userList) {
                if (userCount === 0) {
                    console.log('No users, showing "No participants joined yet" message');
                    userList.innerHTML = '<p style="text-align: center; color: #666;">No participants have joined yet</p>';
                } else {
                    console.log('Building user list HTML for', userCount, 'users');
                    let userListHTML = '';
                    
                    // Ensure users is an array
                    const userArray = Array.isArray(users) ? users : Object.keys(users);
                    
                    for (const username of userArray) {
                        const hasAnswered = userAnswers[username] || false;
                        const statusClass = hasAnswered ? 'answered' : 'pending';
                        const statusIcon = hasAnswered ? '‚úÖ' : '‚è≥';
                        const statusText = hasAnswered ? 'Answered' : 'Pending';
                        
                        userListHTML += `
                            <div class="user-item ${statusClass}">
                                <span class="user-icon">üë§</span>
                                <span class="username">${username}</span>
                                <span class="status">${statusIcon} ${statusText}</span>
                            </div>
                        `;
                    }
                    console.log('Setting user list HTML:', userListHTML);
                    userList.innerHTML = userListHTML;
                    
                    // Also update participant display
                    updateParticipantDisplay();
                    

                }
            } else {
                console.error('userList element not found!');
            }
        }

        function updateUserAnswerStatus(data) {
            // Initialize user answers for current question
            Object.keys(users).forEach(username => {
                if (!(username in userAnswers)) {
                    userAnswers[username] = false;
                }
            });
            
            // Check if we need to update answer status based on question progress
            if (data.current_question !== undefined && data.current_question !== currentQuestion) {
                // New question started, reset all answers
                Object.keys(userAnswers).forEach(username => {
                    userAnswers[username] = false;
                });
            }
            
            // Update question progress display
            updateQuestionProgress();
            updateUserList();
            
            // Update participant display to show current answer status
            updateParticipantDisplay();
            
            // Only update positions when there are actual score changes, not on every status update
            // This prevents the flashing effect during regular polling
            // Positions will be updated separately when scores actually change
        }

        function updateQuestionProgress() {
            const questionProgressDisplay = document.getElementById('questionProgressDisplay');
            const currentQuestionDisplay = document.getElementById('currentQuestionDisplay');
            const answeredStatusDisplay = document.getElementById('answeredStatusDisplay');
            const nextQuestionBtn = document.getElementById('nextQuestionBtn');
            
            if (questionProgressDisplay && currentQuestionDisplay && answeredStatusDisplay) {
                questionProgressDisplay.style.display = 'block';
                currentQuestionDisplay.textContent = `Question ${currentQuestion + 1} of ${totalQuestions}: ${questionText}`;
                
                // Count answered vs pending users
                const answeredCount = Object.values(userAnswers).filter(answered => answered).length;
                const totalUsers = Object.keys(users).length;
                const pendingCount = totalUsers - answeredCount;
                
                answeredStatusDisplay.innerHTML = `
                    <div>‚úÖ Answered: ${answeredCount}/${totalUsers}</div>
                    <div>‚è≥ Pending: ${pendingCount}/${totalUsers}</div>
                `;
                
                // Update user list to reflect current answer status
                updateUserList();
                
                // Update participant display to show current answer status
                updateParticipantDisplay();

                // Check if all users have answered the current question
                if (answeredCount === totalUsers && totalUsers > 0) {
                    questionProgressDisplay.classList.add('all-answered');
                    answeredStatusDisplay.innerHTML += `
                        <div style="margin-top: 0.5rem; font-weight: 600; color: #155724;">
                            üéâ All users have answered! Ready for next question.
                        </div>
                    `;
                    nextQuestionBtn.style.display = 'block'; // Show next question button
                    
                    // All users answered - this triggers score changes, so update positions
                    console.log('All users answered - updating positions due to score changes');
                    loadUserPositions();
                } else {
                    questionProgressDisplay.classList.remove('all-answered');
                    nextQuestionBtn.style.display = 'none'; // Hide next question button
                }
            }
        }

        async function loadFinalResults() {
            try {
                const response = await fetch(`/api/positions/${sessionId}`);
                if (response.ok) {
                    const data = await response.json();
                    showFinalResults(data.positions);
                }
            } catch (error) {
                console.error('Error loading final results:', error);
            }
        }

        function updateStatus() {
            const statusElement = document.getElementById('status');
            if (statusElement) {
                if (sessionStatus === 'waiting') {
                    statusElement.textContent = 'Waiting for students to join...';
                    statusElement.className = 'status waiting';
                } else if (sessionStatus === 'active') {
                    statusElement.textContent = 'Privilege Walk in progress...';
                    statusElement.className = 'status active';
                } else if (sessionStatus === 'finished') {
                    statusElement.textContent = 'Session finished!';
                    statusElement.className = 'status finished';
                }
            }
        }

        function updateUserCount() {
            const userCountElement = document.getElementById('userCount');
            if (userCountElement) {
                userCountElement.textContent = Object.keys(users).length;
            }
        }

        function updateGoButton() {
            const goButton = document.getElementById('goButton');
            if (goButton) {
                goButton.disabled = Object.keys(users).length === 0;
            }
        }

        function showMainView() {
            document.querySelector('.main-content').style.display = 'flex';
            document.getElementById('privilegeWalkView').style.display = 'none';
            document.getElementById('finalResults').style.display = 'none';
            
            // Hide participant display when showing main view
            const participantDisplay = document.getElementById('participantDisplay');
            if (participantDisplay) {
                participantDisplay.style.display = 'none';
            }
        }

        async function showPrivilegeWalkView() {
            document.querySelector('.main-content').style.display = 'none';
            document.getElementById('privilegeWalkView').style.display = 'block';
            document.getElementById('finalResults').style.display = 'none';
            
            // Load current question data first to set window.totalQuestions
            await loadCurrentQuestion();
            
            // Create the walk grid once when the privilege walk starts
            createWalkGrid();
            
            // Create user markers positioned on the grid (now async)
            await createUserMarkers();
            
            // Update participant display when showing privilege walk view
            updateParticipantDisplay();
        }

        async function resetSession() {
            // Reset the current session for new questions
            if (confirm('Reset this session? Students will keep their usernames but start fresh questions.')) {
                try {
                    const response = await fetch('/api/reset_session', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ session_id: sessionId })
                    });
                    
                    const data = await response.json();
                    if (data.success) {
                        // Hide final results
                        document.getElementById('finalResults').style.display = 'none';
                        // Show privilege walk view again
                        await showPrivilegeWalkView();
                        // Reset session state
                        sessionStatus = 'waiting';
                        updateStatus();
                        // Clear previous results
                        document.getElementById('walkContainer').innerHTML = '';
                        // Reset positions loaded flag
                        positionsLoaded = false;
                        // Reset grid created flag
                        gridCreated = false;
                        // Re-enable go button
                        document.getElementById('goButton').disabled = false;
                    }
                } catch (error) {
                    console.error('Error resetting session:', error);
                    alert('Error resetting session');
                }
            }
        }

        function showFinalResults(finalPositions) {
            const finalResults = document.getElementById('finalResults');
            const finalPositionsDiv = document.getElementById('finalPositions');
            
            // Sort by position (highest first)
            const sortedPositions = Object.entries(finalPositions)
                .sort(([,a], [,b]) => b - a);
            
            finalPositionsDiv.innerHTML = sortedPositions.map(([username, position], index) => `
                <div class="position-card">
                    <div class="position-rank">#${index + 1}</div>
                    <div class="position-name">${username}</div>
                    <div class="position-value">Position: ${position.toFixed(1)}</div>
                </div>
            `).join('');
            
            finalResults.style.display = 'block';
        }

        function updateQuestionDisplay(question, questionNumber, totalQuestions) {
            const questionText = document.getElementById('questionText');
            const questionProgress = document.getElementById('questionProgress');
            
            if (questionText) questionText.textContent = question;
            if (questionProgress) questionProgress.textContent = `Question ${questionNumber} of ${totalQuestions}`;
        }

        async function createUserMarkers() {
            const container = document.getElementById('walkContainer');
            
            console.log('=== MARKER CREATION START ===');
            console.log('Current users object:', users);
            console.log('Users type:', typeof users);
            console.log('Users is array:', Array.isArray(users));
            
            // Clear existing markers
            const existingMarkers = container.querySelectorAll('.user-marker');
            console.log(`Found ${existingMarkers.length} existing markers, removing them...`);
            existingMarkers.forEach(marker => {
                console.log('Removing marker:', marker.textContent);
                marker.remove();
            });
            
            // Ensure users is an array
            const userArray = Array.isArray(users) ? users : Object.keys(users);
            const userCount = userArray.length;
            
            console.log(`User array: [${userArray.join(', ')}]`);
            console.log(`User count: ${userCount}`);
            
            if (userCount === 0) {
                console.log('No users, skipping marker creation');
                return;
            }
            
            // Get current positions first to position markers correctly from the start
            try {
                const response = await fetch(`/api/positions/${sessionId}`);
                if (response.ok) {
                    const data = await response.json();
                    const positions = data.positions || {};
                    
                    // Create markers positioned correctly from the start
                    userArray.forEach((username, index) => {
                        const marker = document.createElement('div');
                        marker.className = 'user-marker';
                        marker.id = `marker-${username}`;
                        marker.textContent = username;
                        
                        // Position marker based on current score (avoid the "jump" effect)
                        if (positions[username] !== undefined) {
                            const walkContainer = document.getElementById('walkContainer');
                            const containerWidth = walkContainer.offsetWidth;
                            const columnWidth = containerWidth / userCount;
                            
                            // Calculate horizontal position (column center)
                            const leftPosition = (index + 0.5) * columnWidth;
                            
                            // Calculate vertical position based on score
                            const score = positions[username];
                            const totalQuestions = window.totalQuestions || 12; // Fallback to 12 if not set
                            const maxScore = totalQuestions;
                            const minScore = -totalQuestions;
                            const totalRows = (2 * totalQuestions) + 1;
                            const topPosition = ((maxScore - score) / (totalRows - 1)) * 100; // Flip: minScore = 100%, maxScore = 0%
                            
                            console.log(`Positioning ${username}: column ${index}, left=${leftPosition}px, score=${score}, top=${topPosition}%`);
                            
                            marker.style.left = `${leftPosition}px`;
                            marker.style.top = `${topPosition}%`;
                        } else {
                            // Fallback to center if no position data yet
                            marker.style.left = '50%';
                            marker.style.top = '50%';
                        }
                        
                        // Set initial answer status
                        const hasAnswered = userAnswers[username] || false;
                        marker.classList.add(hasAnswered ? 'answered' : 'pending');
                        
                        container.appendChild(marker);
                    });
                } else {
                    // Fallback: create markers at center if position fetch fails
                    userArray.forEach((username, index) => {
                        const marker = document.createElement('div');
                        marker.className = 'user-marker';
                        marker.id = `marker-${username}`;
                        marker.textContent = username;
                        
                        marker.style.left = '50%';
                        marker.style.top = '50%';
                        
                        const hasAnswered = userAnswers[username] || false;
                        marker.classList.add(hasAnswered ? 'answered' : 'pending');
                        
                        container.appendChild(marker);
                    });
                }
            } catch (error) {
                console.error('Error loading positions for marker creation:', error);
                // Fallback: create markers at center
                userArray.forEach((username, index) => {
                    const marker = document.createElement('div');
                    marker.className = 'user-marker';
                    marker.id = `marker-${username}`;
                    marker.textContent = username;
                    
                    marker.style.left = '50%';
                    marker.style.top = '50%';
                    
                    const hasAnswered = userAnswers[username] || false;
                    marker.classList.add(hasAnswered ? 'answered' : 'pending');
                    
                    container.appendChild(marker);
                });
            }
        }
        
        function createWalkGrid() {
            const walkGrid = document.getElementById('walkGrid');
            const walkContainer = document.getElementById('walkContainer');
            
            console.log('=== GRID CREATION START ===');
            console.log('Current users:', users);
            console.log('Current totalQuestions:', window.totalQuestions);
            
            // Ensure users is an array
            const userArray = Array.isArray(users) ? users : Object.keys(users);
            if (userArray.length === 0) {
                console.log('No users, skipping grid creation');
                return;
            }
            
            // Get the total number of questions for dynamic grid sizing
            const totalQuestions = window.totalQuestions || 12; // Fallback to 12 if not set
            const maxScore = totalQuestions;
            const minScore = -totalQuestions;
            const totalRows = (2 * totalQuestions) + 1; // 2 * questions + 1 to include 0
            
            console.log(`Grid dimensions: ${totalRows} rows (scores ${minScore} to ${maxScore}), ${userArray.length} columns`);
            console.log(`Calculation: 2 * ${totalQuestions} + 1 = ${totalRows} rows`);
            console.log(`Score range: ${minScore} to ${maxScore} (should be -${totalQuestions} to +${totalQuestions})`);
            
            // COMPLETELY CLEAR everything first
            walkGrid.innerHTML = '';
            
            // Remove ALL existing labels from the container
            const allLabels = walkContainer.querySelectorAll('.grid-row-label');
            allLabels.forEach(label => {
                label.remove();
                console.log('Removed row label:', label.textContent);
            });
            
            // Set the CSS grid template rows and columns dynamically
            // Add one extra column for labels (first column)
            walkGrid.style.gridTemplateRows = `repeat(${totalRows}, 1fr)`;
            walkGrid.style.gridTemplateColumns = `80px repeat(${userArray.length}, 1fr)`;
            
            // Create grid cells including label column
            for (let row = 0; row < totalRows; row++) {
                // First column: labels
                const labelCell = document.createElement('div');
                labelCell.className = 'grid-label-cell';
                const score = minScore + row; // From minScore to maxScore
                labelCell.textContent = score;
                walkGrid.appendChild(labelCell);
                
                // Remaining columns: data cells
                for (let col = 0; col < userArray.length; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    walkGrid.appendChild(cell);
                }
            }
            
            // Column labels removed - user markers already show usernames and move with scores
            // No need for duplicate username displays
            
            // Mark grid as created
            gridCreated = true;
            console.log('=== GRID CREATION COMPLETE ===');
            console.log(`Final grid: ${totalRows} rows, ${userArray.length + 1} columns (1 label + ${userArray.length} data)`);
            console.log(`Label cells created: ${walkContainer.querySelectorAll('.grid-label-cell').length}`);
            console.log(`Data cells created: ${walkContainer.querySelectorAll('.grid-cell').length}`);
        }

        function updateUserPositions(positions) {
            if (!positions) return;
            
            const walkContainer = document.getElementById('walkContainer');
            const containerWidth = walkContainer.offsetWidth;
            const containerHeight = walkContainer.offsetHeight;
            
            // Ensure users is an array
            const userArray = Array.isArray(users) ? users : Object.keys(users);
            const userCount = userArray.length;
            
            if (userCount === 0) return;
            
            const columnWidth = containerWidth / userCount;
            
            Object.keys(positions).forEach(username => {
                const marker = document.getElementById(`marker-${username}`);
                if (marker) {
                    // Find user's column index
                    const userIndex = userArray.indexOf(username);
                    if (userIndex === -1) return;
                    
                    
                    // Calculate horizontal position (column center)
                    // Account for the label column (80px) and the user's column position
                    const labelColumnWidth = 80;
                    const dataColumnWidth = (containerWidth - labelColumnWidth) / userCount;
                    const leftPosition = labelColumnWidth + (userIndex + 0.5) * dataColumnWidth;
                    
                    // Calculate vertical position based on score
                    // Score ranges from -totalQuestions to +totalQuestions, convert to 0-100%
                    // minScore should be at bottom (100%), maxScore should be at top (0%)
                    const score = positions[username];
                    const totalQuestions = window.totalQuestions || 12; // Fallback to 12 if not set
                    const maxScore = totalQuestions;
                    const minScore = -totalQuestions;
                    const totalRows = (2 * totalQuestions) + 1;
                    // Convert score to row index: score - minScore
                    const rowIndex = score - minScore;
                    // Position at the center of the corresponding row
                    const topPosition = ((rowIndex + 0.5) / totalRows) * 100;
                    
                    // Position marker on the grid
                    marker.style.left = `${leftPosition}px`;
                    marker.style.top = `${topPosition}%`;
                    
                    // Update answer status
                    const hasAnswered = userAnswers[username] || false;
                    marker.classList.remove('answered', 'pending');
                    marker.classList.add(hasAnswered ? 'answered' : 'pending');
                }
            });
            
            // Store current positions for change detection
            lastKnownPositions = { ...positions };
            
            // Update user list to reflect answer status
            updateUserList();
        }

        function createNewSession() {
            // Create a completely new session
            if (confirm('Create a new session? This will generate a new QR code and session ID.')) {
                window.location.href = '/';
            }
        }

        async function testViewTransition() {
            console.log('=== TESTING VIEW TRANSITION ===');
            console.log('Current session status:', sessionStatus);
            console.log('Current users:', users);
            
            // Test the transition manually
            await showPrivilegeWalkView();
            
            // After 3 seconds, go back
            setTimeout(() => {
                console.log('Going back to main view...');
                showMainView();
            }, 3000);
        }

        // Function to refresh QR code
        function refreshQRCode() {
            const qrImage = document.getElementById('qrCodeImage');
            const timestamp = new Date().getTime();
            qrImage.src = `/qr/{{ session_id }}?t=${timestamp}`;
        }

        // Function to refresh IP address display
        function refreshIPAddress() {
            // Reload the page to get updated IP address
            window.location.reload();
        }

        // Function to copy join URL to clipboard
        function copyJoinURL() {
            const joinUrlElement = document.getElementById('joinUrl');
            const joinURL = joinUrlElement ? joinUrlElement.textContent : `{{ base_url }}/join/${sessionId}`;
            
            navigator.clipboard.writeText(joinURL).then(() => {
                alert('Join URL copied to clipboard!');
            }).catch(() => {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = joinURL;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                alert('Join URL copied to clipboard!');
            });
        }

        // Handle start button click
        document.getElementById('startBtn').addEventListener('click', async function() {
            console.log('üöÄ START BUTTON CLICKED!');
            try {
                console.log('Sending start session request...');
                const response = await fetch('/api/start_session', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ session_id: sessionId })
                });
                
                const data = await response.json();
                console.log('Start session response:', data);
                if (!data.success) {
                    alert('Error starting session: ' + data.error);
                } else {
                    console.log('‚úÖ Session start request successful');
                    // Hide start button, show stop button
                    document.getElementById('startBtn').style.display = 'none';
                    document.getElementById('stopBtn').style.display = 'inline-block';
                    
                    // Update participant display to show during active session
                    updateParticipantDisplay();
                    
                    // Load the first question and update display
                    await loadCurrentQuestion();
                }
            } catch (error) {
                console.error('Error:', error);
                alert('Error starting session');
            }
        });

        // Handle stop button click
        document.getElementById('stopBtn').addEventListener('click', async function() {
            console.log('‚èπÔ∏è STOP BUTTON CLICKED!');
            try {
                // For now, just reset the session
                const response = await fetch('/api/reset_session', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ session_id: sessionId })
                });
                
                const data = await response.json();
                if (data.success) {
                    // Show start button, hide stop button
                    document.getElementById('startBtn').style.display = 'inline-block';
                    document.getElementById('stopBtn').style.display = 'none';
                    // Reset to main view
                    showMainView();
                }
            } catch (error) {
                console.error('Error:', error);
                alert('Error stopping session');
            }
        });

        // Handle next question button click
        document.getElementById('nextQuestionBtn').addEventListener('click', async function() {
            console.log('Next Question Button Clicked!');
            try {
                const response = await fetch(`/api/advance_question/${sessionId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ session_id: sessionId })
                });
                const data = await response.json();
                console.log('Advance question response:', data);
                if (data.success) {
                    console.log('‚úÖ Question advanced successfully');
                    // Reload current question and progress
                    await loadCurrentQuestion();
                    updateQuestionProgress();
                    // Re-create user markers to update their positions
                    await createUserMarkers();
                    
                    // Update participant display for new question
                    updateParticipantDisplay();
                } else {
                    alert('Error advancing question: ' + data.error);
                }
            } catch (error) {
                console.error('Error advancing question:', error);
                alert('Error advancing question');
            }
        });

        // Function to advance to next question (called from onclick)
        async function advanceToNextQuestion() {
            console.log('Next Question Button Clicked!');
            try {
                const response = await fetch(`/api/advance_question/${sessionId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ session_id: sessionId })
                });
                const data = await response.json();
                console.log('Advance question response:', data);
                if (data.success) {
                    console.log('‚úÖ Question advanced successfully');
                    // Reload current question and progress
                    await loadCurrentQuestion();
                    updateQuestionProgress();
                    // Re-create user markers to update their positions
                    await createUserMarkers();
                    
                    // Update participant display for new question
                    updateParticipantDisplay();
                } else {
                    alert('Error advancing question: ' + data.error);
                }
            } catch (error) {
                console.error('Error advancing question:', error);
                alert('Error advancing question');
            }
        }
        
        async function resumeSession() {
            // Reload all session data
            loadCurrentQuestion();
            updateQuestionProgress();
            loadUserPositions();
            loadUserAnswers();
            await createUserMarkers();
            
            // Update participant display
            updateParticipantDisplay();
        }
        
        function manualRefresh() {
            console.log('Manual refresh requested...');
            loadUserCount();
            loadCurrentQuestion();
            
            // Also update participant display
            updateParticipantDisplay();
        }
        

        

        
        function updateSessionStatusMessage(status) {
            const statusMessage = document.getElementById('sessionStatusMessage');
            if (statusMessage) {
                if (status === 'waiting') {
                    statusMessage.innerHTML = '‚úÖ Session is ready - participants can join now!';
                    statusMessage.style.background = '#d4edda';
                    statusMessage.style.color = '#155724';
                } else if (status === 'active') {
                    statusMessage.innerHTML = 'üöÄ Session is in progress - questions are active';
                    statusMessage.style.background = '#fff3cd';
                    statusMessage.style.color = '#856404';
                } else if (status === 'finished') {
                    statusMessage.innerHTML = 'üèÅ Session completed';
                    statusMessage.style.background = '#d1ecf1';
                    statusMessage.style.color = '#0c5460';
                }
            }
            
            // Also update the question display when status changes
            if (status === 'active') {
                // Load the current question when session becomes active
                loadCurrentQuestion();
            }
        }
        
        function updateParticipantDisplay() {
            const participantDisplay = document.getElementById('participantDisplay');
            const participantList = document.getElementById('participantList');
            
            if (participantDisplay && participantList) {
                if (userCount === 0) {
                    participantDisplay.style.display = 'none';
                    return;
                }
                
                // Show participant display during active sessions
                if (currentQuestion > 0 || document.getElementById('privilegeWalkView').style.display !== 'none') {
                    participantDisplay.style.display = 'block';
                    
                    // Ensure users is an array
                    const userArray = Array.isArray(users) ? users : Object.keys(users);
                    
                    let participantHTML = '';
                    for (const username of userArray) {
                        const hasAnswered = currentQuestion > 0 ? (userAnswers[username] || false) : false;
                        const statusClass = hasAnswered ? 'participant-answered' : 'participant-pending';
                        const statusIcon = hasAnswered ? '‚úÖ' : '‚è≥';
                        
                        participantHTML += `
                            <div class="participant-item ${statusClass}">
                                <div class="participant-info">
                                    <span class="participant-name">${username}</span>
                                    <span class="participant-status">${statusIcon} ${hasAnswered ? 'Answered' : 'Pending'}</span>
                                </div>
                                <div class="participant-score" id="score-${username}">--</div>
                            </div>
                        `;
                    }
                    
                    participantList.innerHTML = participantHTML;
                } else {
                    participantDisplay.style.display = 'none';
                }
            }
        }
        
        function refreshQRCode() {
            const qrImage = document.getElementById('qrCodeImage');
            if (qrImage) {
                qrImage.src = `/qr/${sessionId}?t=${Date.now()}`;
            }
        }
        
        function copyJoinURL() {
            const joinUrlElement = document.getElementById('joinUrl');
            const joinURL = joinUrlElement ? joinUrlElement.textContent : `{{ base_url }}/join/${sessionId}`;
            
            navigator.clipboard.writeText(joinURL).then(() => {
                alert('Join URL copied to clipboard!');
            }).catch(() => {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = joinURL;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                alert('Join URL copied to clipboard!');
            });
        }

        // Function to check for REAL changes that require position updates (prevents flashing)
        function checkForRealChanges(data) {
            // Only update positions if there are actual score changes
            // This is the most restrictive check to prevent any flashing
            
            // Check if positions have actually changed (only real score changes)
            if (data.positions && lastKnownPositions) {
                const currentPositions = JSON.stringify(data.positions);
                const lastPositions = JSON.stringify(lastKnownPositions);
                if (currentPositions !== lastPositions) {
                    console.log('Real score changes detected, updating positions');
                    return true;
                }
            }
            
            // Check if question has changed (new question started)
            if (data.current_question !== undefined && data.current_question !== lastKnownQuestion) {
                lastKnownQuestion = data.current_question;
                console.log('New question started, updating positions');
                return true;
            }
            
            // No real changes that require position updates
            return false;
        }
        
        // Start polling when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Instructor page loaded, starting polling...');
            
            // Set the join URL dynamically
            const joinUrlElement = document.getElementById('joinUrl');
            if (joinUrlElement) {
                const baseUrl = '{{ base_url }}'; // Use the server-provided base URL
                const joinUrl = `${baseUrl}/join/${sessionId}`;
                joinUrlElement.textContent = joinUrl;
                console.log('Join URL set to:', joinUrl);
            }
            
            // Load initial data immediately
            loadUserCount();
            loadCurrentQuestion();
            
            // Start polling for updates
            startPolling();
            
            // Also update the session status message initially
            updateSessionStatusMessage('waiting');
        });
        


        // Clean up polling when page unloads
        window.addEventListener('beforeunload', function() {
            if (pollInterval) {
                clearInterval(pollInterval);
            }
        });
    </script>
</body>
</html> 